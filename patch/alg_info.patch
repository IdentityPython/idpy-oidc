diff --git a/src/idpyoidc/__init__.py b/src/idpyoidc/__init__.py
index 76d83a3..834b77a 100644
--- a/src/idpyoidc/__init__.py
+++ b/src/idpyoidc/__init__.py
@@ -1,5 +1,5 @@
 __author__ = "Roland Hedberg"
-__version__ = "4.3.0"
+__version__ = "5.0.0"

 VERIFIED_CLAIM_PREFIX = "__verified"

@@ -10,7 +10,7 @@ def verified_claim_name(claim):

 def proper_path(path):
     """
-    Clean up the path specification so it looks like something I could use.
+    Clean up the path specification such that it looks like something I could use.
     "./" <path> "/"
     """
     if path.startswith("./"):

diff --git a/src/idpyoidc/alg_info.py b/src/idpyoidc/alg_info.py
new file mode 100644
index 0000000..f3a9641
--- /dev/null
+++ b/src/idpyoidc/alg_info.py
@@ -0,0 +1,67 @@
+from functools import cmp_to_key
+import logging
+
+from cryptojwt.jwe import DEPRECATED
+from cryptojwt.jwe import SUPPORTED
+from cryptojwt.jws.jws import SIGNER_ALGS
+
+logger = logging.getLogger(__name__)
+
+SIGNING_ALGORITHM_SORT_ORDER = ["RS", "ES", "PS", "HS", "Ed"]
+
+
+def cmp(a, b):
+    return (a > b) - (a < b)
+
+
+def alg_cmp(a, b):
+    if a == "none":
+        return 1
+    elif b == "none":
+        return -1
+
+    _pos1 = SIGNING_ALGORITHM_SORT_ORDER.index(a[0:2])
+    _pos2 = SIGNING_ALGORITHM_SORT_ORDER.index(b[0:2])
+    if _pos1 == _pos2:
+        return (a > b) - (a < b)
+    elif _pos1 > _pos2:
+        return 1
+    else:
+        return -1
+
+
+def get_signing_algs():
+    # Assumes Cryptojwt
+    _algs = [name for name in list(SIGNER_ALGS.keys()) if name != "none" and name not in DEPRECATED["alg"]]
+    return sorted(_algs, key=cmp_to_key(alg_cmp))
+
+
+def get_encryption_algs():
+    return SUPPORTED["alg"]
+
+
+def get_encryption_encs():
+    return SUPPORTED["enc"]
+
+
+def array_or_singleton(claim_spec, values):
+    if isinstance(claim_spec[0], list):
+        if isinstance(values, list):
+            return values
+        else:
+            return [values]
+    else:
+        if isinstance(values, list):
+            return values[0]
+        else:  # singleton
+            return values
+
+
+def is_subset(a, b):
+    if isinstance(a, list):
+        if isinstance(b, list):
+            return set(b).issubset(set(a))
+    elif isinstance(b, list):
+        return a in b
+    else:
+        return a == b

diff --git a/src/idpyoidc/claims.py b/src/idpyoidc/claims.py
index e684624..afa6680 100644
--- a/src/idpyoidc/claims.py
+++ b/src/idpyoidc/claims.py
@@ -1,4 +1,6 @@
+import logging
 from typing import Callable
+from typing import List
 from typing import Optional

 from cryptojwt import KeyJar
@@ -7,9 +9,14 @@ from cryptojwt.utils import importer

 from idpyoidc.client.util import get_uri
 from idpyoidc.impexp import ImpExp
+from idpyoidc.key_import import import_jwks
+from idpyoidc.key_import import store_under_other_id
+from idpyoidc.message import Message
+from idpyoidc.transform import preferred_to_registered
 from idpyoidc.util import add_path
 from idpyoidc.util import qualified_name

+logger = logging.getLogger(__name__)

 def claims_dump(info, exclude_attributes):
     return {qualified_name(info.__class__): info.dump(exclude_attributes=exclude_attributes)}
@@ -85,7 +92,17 @@ class Claims(ImpExp):
         self.callback = callbacks

     def verify_rules(self, supports):
-        return True
+        if self.get_preference("encrypt_userinfo_supported", False) is True:
+            self.set_preference("userinfo_encryption_alg_values_supported", [])
+            self.set_preference("userinfo_encryption_enc_values_supported", [])
+
+        if self.get_preference("encrypt_request_object_supported", False) is True:
+            self.set_preference("request_object_encryption_alg_values_supported", [])
+            self.set_preference("request_object_encryption_enc_values_supported", [])
+
+        if self.get_preference("encrypt_id_token_supported", False) is True:
+            self.set_preference("id_token_encryption_alg_values_supported", [])
+            self.set_preference("id_token_encryption_enc_values_supported", [])

     def locals(self, info):
         pass
@@ -104,11 +121,11 @@ class Claims(ImpExp):
             else:
                 _keyjar = KeyJar()
                 if "jwks" in conf:
-                    _keyjar.import_jwks(conf["jwks"], "")
+                    _keyjar = import_jwks(_keyjar, conf["jwks"], "")

             if "" in _keyjar and entity_id:
                 # make sure I have the keys under my own name too (if I know it)
-                _keyjar.import_jwks_as_json(_keyjar.export_jwks_as_json(True, ""), entity_id)
+                _keyjar = store_under_other_id(_keyjar, "", entity_id, True)

             _httpc_params = conf.get("httpc_params")
             if _httpc_params:
@@ -122,7 +139,7 @@ class Claims(ImpExp):

         return keyjar, _uri_path

-    def get_base_url(self, configuration: dict, entity_id: Optional[str]=""):
+    def get_base_url(self, configuration: dict, entity_id: Optional[str] = ""):
         raise NotImplementedError()

     def get_id(self, configuration: dict):
@@ -138,6 +155,7 @@ class Claims(ImpExp):
                     configuration: dict,
                     keyjar: Optional[KeyJar] = None,
                     entity_id: Optional[str] = ""):
+        logger.debug(f"configuration: {configuration}")
         _jwks = _jwks_uri = None
         _id = self.get_id(configuration)
         keyjar, uri_path = self._keyjar(keyjar, configuration, entity_id=_id)
@@ -180,6 +198,10 @@ class Claims(ImpExp):
             elif val:
                 self.set_preference(key, val)

+        for attr, val in supports.items():
+            if attr not in self.prefer and val is not None:
+                self.set_preference(attr, val)
+
         self.verify_rules(supports)
         return keyjar

@@ -195,15 +217,21 @@ class Claims(ImpExp):
     def construct_uris(self, *args):
         pass

-    def supports(self):
+    def _expand(self, dictionary):
         res = {}
-        for key, val in self._supports.items():
+        for key, val in dictionary.items():
             if isinstance(val, Callable):
                 res[key] = val()
             else:
-                res[key] = val
+                if isinstance(val, dict):
+                    res[key] = self._expand(val)
+                else:
+                    res[key] = val
         return res

+    def supports(self):
+        return self._expand(self._supports)
+
     def supported(self, claim):
         return claim in self._supports

@@ -219,3 +247,77 @@ class Claims(ImpExp):
             return default
         else:
             return _val
+
+    def get_endpoint_claims(self, endpoints):
+        _info = {}
+        for endp in endpoints:
+            if endp.endpoint_name:
+                _info[endp.endpoint_name] = endp.full_path
+                for arg, claim in [("client_authn_method", "auth_methods"),
+                                   ("auth_signing_alg_values", "auth_signing_alg_values")]:
+                    _val = getattr(endp, arg, None)
+                    if _val:
+                        # trust_mark_status_endpoint_auth_methods_supported
+                        md_param = f"{endp.endpoint_name}_{claim}"
+                        _info[md_param] = _val
+        return _info
+
+    def get_server_metadata(self,
+                            entity_type: Optional[str] = "",
+                            endpoints: Optional[list] = None,
+                            metadata_schema: Optional[Message] = None,
+                            extra_claims: Optional[List[str]] = None,
+                            **kwargs):
+
+        metadata = self.prefer
+        # the claims that can appear in the metadata
+        if metadata_schema:
+            attr = list(metadata_schema.c_param.keys())
+        else:
+            attr = []
+
+        if extra_claims:
+            attr.extend(extra_claims)
+
+        if attr:
+            metadata = {k: v for k, v in metadata.items() if k in attr and v != []}
+
+        # collect endpoints
+        if endpoints:
+            metadata.update(self.get_endpoint_claims(endpoints))
+
+        if entity_type:
+            return {entity_type: metadata}
+        else:
+            return metadata
+
+    def get_client_metadata(self,
+                            entity_type: Optional[str] = "",
+                            metadata_schema: Optional[Message] = None,
+                            extra_claims: Optional[List[str]] = None,
+                            supported: Optional[dict] = None,
+                            **kwargs):
+
+        if supported is None:
+            supported = self.supports()
+
+        if not self.use:
+            self.use = preferred_to_registered(self.prefer, supported=supported)
+
+        metadata = self.use
+        # the claims that can appear in the metadata
+        if metadata_schema:
+            attr = list(metadata_schema.c_param.keys())
+        else:
+            attr = []
+
+        if extra_claims:
+            attr.extend(extra_claims)
+
+        if attr:
+            metadata = {k: v for k, v in metadata.items() if k in attr}
+
+        if entity_type:
+            return {entity_type: metadata}
+        else:
+            return metadata

diff --git a/src/idpyoidc/client/entity_metadata.py b/src/idpyoidc/client/entity_metadata.py
new file mode 100644
index 0000000..6b41b55
--- /dev/null
+++ b/src/idpyoidc/client/entity_metadata.py
@@ -0,0 +1,36 @@
+from typing import Optional
+
+from idpyoidc.impexp import ImpExp
+
+
+class EntityMetadata(ImpExp):
+    parameter = {"metadata": {}}
+    def __init__(self, metadata: Optional[dict] = None):
+        ImpExp.__init__(self)
+        if metadata is None:
+            self.metadata = {}
+        else:
+            self.metadata = metadata
+
+    def __getitem__(self, item):
+        for _type, _dict in self.metadata.items():
+            _val = _dict.get(item, None)
+            if _val:
+                return _val
+        raise KeyError(item)
+
+    def __setitem__(self, key, value):
+        # Assumes not multiple entity types
+        self.metadata[key] = value
+
+    def items(self):
+        return self.metadata.items()
+
+    def __contains__(self, item):
+        return item in self.metadata
+
+    def get(self, item, default=None):
+        return self.metadata.get(item, default)
+
+    def to_dict(self):
+        return self.metadata


diff --git a/src/idpyoidc/client/oauth2/access_token.py b/src/idpyoidc/client/oauth2/access_token.py
index 6ccb6f4..5161aa0 100644
--- a/src/idpyoidc/client/oauth2/access_token.py
+++ b/src/idpyoidc/client/oauth2/access_token.py
@@ -7,7 +7,7 @@ from idpyoidc.client.oauth2.utils import get_state_parameter
 from idpyoidc.client.service import Service
 from idpyoidc.message import oauth2
 from idpyoidc.message.oauth2 import ResponseMessage
-from idpyoidc.metadata import get_signing_algs
+from idpyoidc.alg_info import get_signing_algs
 from idpyoidc.time_util import time_sans_frac

 LOGGER = logging.getLogger(__name__)

diff --git a/src/idpyoidc/client/provider/github.py b/src/idpyoidc/client/provider/github.py
index 56c9103..674a78d 100644
--- a/src/idpyoidc/client/provider/github.py
+++ b/src/idpyoidc/client/provider/github.py
@@ -1,12 +1,12 @@
+from idpyoidc.alg_info import get_signing_algs
 from idpyoidc.client.client_auth import get_client_authn_methods
 from idpyoidc.client.oauth2 import access_token
 from idpyoidc.client.oidc import userinfo
+from idpyoidc.message import Message
 from idpyoidc.message import SINGLE_OPTIONAL_STRING
 from idpyoidc.message import SINGLE_REQUIRED_STRING
-from idpyoidc.message import Message
 from idpyoidc.message import oauth2
 from idpyoidc.message.oauth2 import ResponseMessage
-from idpyoidc.metadata import get_signing_algs


 class AccessTokenResponse(Message):
diff --git a/src/idpyoidc/client/provider/linkedin.py b/src/idpyoidc/client/provider/linkedin.py
index 17c7e85..e0bc430 100644
--- a/src/idpyoidc/client/provider/linkedin.py
+++ b/src/idpyoidc/client/provider/linkedin.py
@@ -1,13 +1,13 @@
+from idpyoidc.alg_info import get_signing_algs
 from idpyoidc.client.client_auth import get_client_authn_methods
 from idpyoidc.client.oauth2 import access_token
 from idpyoidc.client.oidc import userinfo
+from idpyoidc.message import Message
 from idpyoidc.message import SINGLE_OPTIONAL_JSON
 from idpyoidc.message import SINGLE_OPTIONAL_STRING
 from idpyoidc.message import SINGLE_REQUIRED_INT
 from idpyoidc.message import SINGLE_REQUIRED_STRING
-from idpyoidc.message import Message
 from idpyoidc.message import oauth2
-from idpyoidc.metadata import get_signing_algs


 class AccessTokenResponse(Message):


diff --git a/src/idpyoidc/client/rp_handler.py b/src/idpyoidc/client/rp_handler.py
index eea94c0..33d02f5 100644
--- a/src/idpyoidc/client/rp_handler.py
+++ b/src/idpyoidc/client/rp_handler.py
@@ -3,19 +3,24 @@ import sys
 import traceback
 from typing import List
 from typing import Optional
+from typing import Union

 from cryptojwt import KeyJar
+from cryptojwt.key_jar import build_keyjar
 from cryptojwt.key_jar import init_key_jar
 from cryptojwt.utils import as_bytes
 from cryptojwt.utils import importer

+from idpyoidc.client.configure import RPHConfiguration
 from idpyoidc.client.defaults import DEFAULT_CLIENT_CONFIGS
 from idpyoidc.client.defaults import DEFAULT_OIDC_SERVICES
-from idpyoidc.client.defaults import DEFAULT_RP_KEY_DEFS
 from idpyoidc.client.oauth2.stand_alone_client import StandAloneClient
+from idpyoidc.configure import Base
 from idpyoidc.util import add_path
 from idpyoidc.util import rndstr
+from .defaults import DEFAULT_KEY_DEFS
 from .oauth2 import Client
+from ..key_import import import_jwks
 from ..message import Message

 logger = logging.getLogger(__name__)
@@ -34,50 +39,51 @@ class RPHandler(object):
             state_db=None,
             httpc=None,
             httpc_params=None,
-            config=None,
+            config: Optional[Union[dict, Base]] = None,
             **kwargs,
     ):
-        self.base_url = base_url
-
-        if keyjar is None:
-            keyjar_defs = {}
-            if config:
-                keyjar_defs = getattr(config, "key_conf", None)
-
-            if not keyjar_defs:
-                keyjar_defs = kwargs.get("key_conf", DEFAULT_RP_KEY_DEFS)
-
-            _jwks_path = kwargs.get("jwks_path", keyjar_defs.get("uri_path", keyjar_defs.get("public_path", "")))
-            if "uri_path" in keyjar_defs:
-                del keyjar_defs["uri_path"]
-            self.keyjar = init_key_jar(**keyjar_defs, issuer_id="")
-            self.keyjar.import_jwks_as_json(self.keyjar.export_jwks_as_json(True, ""), base_url)
-        else:
+        if config is None:
+            config = RPHConfiguration({})
+        elif isinstance(config, dict):
+            config = RPHConfiguration(config)
+
+        self.base_url = base_url or config.get("base_url", config.get("entity_id", ""))
+        self.entity_id = config.get("entity_id", config.conf.get("entity_id", self.base_url))
+        self.entity_type = config.get("entity_type", config.conf.get("entity_type", ""))
+        self.client_type = config.get("client_type", config.conf.get("client_type", ""))
+        self.client_configs = client_configs or {}
+
+        if keyjar:
             self.keyjar = keyjar
             _jwks_path = kwargs.get("jwks_path", "")
-
-        if _jwks_path:
-            self.jwks_uri = add_path(base_url, _jwks_path)
-        else:
-            self.jwks_uri = ""
-            if len(self.keyjar):
-                self.jwks = self.keyjar.export_jwks()
+            if _jwks_path:
+                self.jwks_uri = add_path(base_url, _jwks_path)
             else:
-                self.jwks = {}
+                self.jwks_uri = ""
+                if len(self.keyjar):
+                    self.jwks = self.keyjar.export_jwks()
+                else:
+                    self.jwks = {}

         if config:
             if not hash_seed:
                 self.hash_seed = config.hash_seed
-            if not keyjar:
-                self.keyjar = init_key_jar(**config.key_conf, issuer_id="")
-            if not client_configs:
-                self.client_configs = config.clients
-
-            if "client_class" in config:
-                if isinstance(config["client_class"], str):
-                    self.client_cls = importer(config["client_class"])
+
+            if not keyjar and config.key_conf:
+                _conf = {k: v for k, v in config.key_conf.items() if k != "uri_path"}
+                self.keyjar = init_key_jar(**_conf, issuer_id="")
+                _jwks_path = kwargs.get("jwks_path",
+                                        config.key_conf.get("uri_path",
+                                                            config.key_conf.get("public_path", "")))
+                if _jwks_path:
+                    self.jwks_uri = add_path(self.base_url, _jwks_path)
+
+            _c_class = config.get("client_class", config.conf.get("client_class"))
+            if _c_class:
+                if isinstance(_c_class, str):
+                    self.client_cls = importer(_c_class)
                 else:  # assume it's a class
-                    self.client_cls = config["client_class"]
+                    self.client_cls = _c_class
             else:
                 self.client_cls = StandAloneClient
         else:
@@ -86,23 +92,22 @@ class RPHandler(object):
             else:
                 self.hash_seed = as_bytes(rndstr(32))

-            if client_configs is None:
-                self.client_configs = DEFAULT_CLIENT_CONFIGS
-                for param in ["client_type", "preference", "add_ons"]:
-                    val = kwargs.get(param, None)
-                    if val:
-                        self.client_configs[""][param] = val
-            else:
-                self.client_configs = client_configs
-
             _cc = kwargs.get("client_class", None)
             if _cc:
                 if isinstance(_cc, str):
                     _cc = importer(_cc)
-                self.client_cls =_cc
+                self.client_cls = _cc
             else:
                 self.client_cls = StandAloneClient

+        if client_configs is None:
+            self.client_configs = DEFAULT_CLIENT_CONFIGS
+            for param in ["client_type", "preference", "add_ons"]:
+                val = kwargs.get(param, None)
+                if val:
+                    self.client_configs[""][param] = val
+        else:
+            self.client_configs = client_configs

         if state_db:
             self.state_db = state_db
@@ -111,6 +116,9 @@ class RPHandler(object):

         self.extra = kwargs

+        if services is None:
+            services = config.get("services", config.conf.get("services", None))
+
         if services is None:
             self.services = DEFAULT_OIDC_SERVICES
         else:
@@ -122,15 +130,20 @@ class RPHandler(object):
         self.httpc = httpc

         if not httpc_params:
-            self.httpc_params = {"verify": verify_ssl}
+            self.httpc_params = config.get("httpc_params", {"verify": verify_ssl})
         else:
             self.httpc_params = httpc_params

-        if not self.keyjar.httpc_params:
-            self.keyjar.httpc_params = self.httpc_params
-
         self.upstream_get = kwargs.get("upstream_get", None)

+        _keyjar = getattr(self, "keyjar", None)
+        if _keyjar is not None:
+            if not _keyjar.httpc_params:
+                _keyjar.httpc_params = getattr(self, "httpc_params", {})
+        else:
+            self.keyjar = build_keyjar(DEFAULT_KEY_DEFS)
+            self.keyjar.httpc_params = getattr(self, "httpc_params", {})
+
     def state2issuer(self, state):
         """
         Given the state value find the Issuer ID of the OP/AS that state value
@@ -159,7 +172,13 @@ class RPHandler(object):
         :param issuer: Issuer ID
         :return: A client configuration
         """
-        return self.client_configs[issuer]
+        _cnf = self.client_configs[issuer].copy()
+        for param in ["entity_id", "client_id", "base_url", "services", "jwks_uri", "entity_type",
+                      "client_type"]:
+            if param not in _cnf and getattr(self, param, None):
+                _cnf[param] = getattr(self, param)
+
+        return _cnf

     def get_session_information(self, key, client=None):
         """
@@ -192,16 +211,7 @@ class RPHandler(object):
             _cnf = self.pick_config("")
             _cnf["issuer"] = issuer

-        try:
-            _services = _cnf["services"]
-        except KeyError:
-            _services = self.services
-
-        if "base_url" not in _cnf:
-            _cnf["base_url"] = self.base_url
-
-        if self.jwks_uri:
-            _cnf["jwks_uri"] = self.jwks_uri
+        _services = _cnf["services"]

         logger.debug(f"config: {_cnf}")
         try:
@@ -221,20 +231,29 @@ class RPHandler(object):
         _context = client.get_context()
         if _context.iss_hash:
             self.hash2issuer[_context.iss_hash] = issuer
+
         # If non persistent
         _keyjar = client.keyjar
-        if not _keyjar:
+        if _keyjar is None:
             _keyjar = KeyJar()
             _keyjar.httpc_params.update(self.httpc_params)

-        for iss in self.keyjar.owners():
-            _keyjar.import_jwks(self.keyjar.export_jwks(issuer_id=iss, private=True), iss)
+        if self.upstream_get:
+            _srv_keyjar = self.upstream_get("attribute", "keyjar")
+        else:
+            _srv_keyjar = getattr(self, "keyjar", None)
+
+        if _srv_keyjar:
+            for iss in _srv_keyjar.owners():
+                _keyjar = import_jwks(_keyjar, self.keyjar.export_jwks(issuer_id=iss, private=True), iss)

         client.keyjar = _keyjar
         # If persistent nothing has to be copied

-        _context.base_url = self.base_url
-        _context.jwks_uri = self.jwks_uri
+        for item in ["jwks_uri", "base_url"]:
+            _val = getattr(self, item, None)
+            if _val:
+                setattr(_context, item, _val)
         return client

     def do_provider_info(
@@ -639,7 +658,8 @@ class RPHandler(object):
         return client.logout(state, post_logout_redirect_uri=post_logout_redirect_uri)

     def close(
-            self, state: str, issuer: Optional[str] = "", post_logout_redirect_uri: Optional[str] = ""
+            self, state: str, issuer: Optional[str] = "",
+            post_logout_redirect_uri: Optional[str] = ""
     ) -> dict:

         if issuer:

diff --git a/src/idpyoidc/key_import.py b/src/idpyoidc/key_import.py
new file mode 100644
index 0000000..9b33f50
--- /dev/null
+++ b/src/idpyoidc/key_import.py
@@ -0,0 +1,76 @@
+import json
+from typing import List
+from typing import Optional
+
+from cryptojwt import JWK
+from cryptojwt import KeyBundle
+from cryptojwt import KeyJar
+from cryptojwt.jwk.hmac import SYMKey
+from cryptojwt.jwk.jwk import key_from_jwk_dict
+
+
+def issuer_keys(keyjar: KeyJar, entity_id: str, format: Optional[str] = "jwk"):
+    # sort of copying the functionality in KeyJar.get_issuer_keys()
+    key_issuer = keyjar.return_issuer(entity_id)
+    if format == "jwk":
+        return [k.serialize() for k in key_issuer.all_keys()]
+    else:
+        return [k for k in key_issuer.all_keys()]
+
+
+def import_jwks(keyjar: KeyJar, jwks: dict, entity_id: Optional[str] = "") -> KeyJar:
+    keys = []
+    jar = issuer_keys(keyjar, entity_id)
+    for jwk in jwks["keys"]:
+        if jwk not in jar:
+            jar.append(jwk)
+            key = key_from_jwk_dict(jwk)
+            keys.append(key)
+    if keys:
+        keyjar.add_keys(entity_id, keys)
+    return keyjar
+
+
+def import_jwks_as_json(keyjar: KeyJar, jwks: str, entity_id: Optional[str] = "") -> KeyJar:
+    return import_jwks(keyjar, json.loads(jwks), entity_id)
+
+
+def import_jwks_from_file(keyjar: KeyJar, filename: str, entity_id) -> KeyJar:
+    with open(filename) as jwks_file:
+        keyjar = import_jwks_as_json(keyjar, jwks_file.read(), entity_id)
+    return keyjar
+
+
+def add_kb(keyjar: KeyJar, key_bundle: KeyBundle, entity_id: str) -> KeyJar:
+    return import_jwks(keyjar, json.loads(key_bundle.jwks()), entity_id)
+
+
+def add_symmetric(keyjar: KeyJar, key: str, entity_id: Optional[str] = "") -> KeyJar:
+    jar = issuer_keys(keyjar, entity_id)
+    _sym_key = SYMKey(key=key)
+
+    jwk = _sym_key.serialize()
+    if jwk not in jar:
+        keyjar.add_symmetric(entity_id, key)
+    return keyjar
+
+
+def store_under_other_id(keyjar: KeyJar, fro: Optional[str] = "", to: Optional[str] = "",
+                         private: Optional[bool] = False) -> KeyJar:
+    if fro == to:
+        return keyjar
+    else:
+        return import_jwks(keyjar, keyjar.export_jwks(private, fro), to)
+
+
+def add_keys(keyjar:KeyJar, keys: List[JWK], entity_id) -> KeyJar:
+    _keys = []
+    jar = issuer_keys(keyjar, entity_id)
+    for key in keys:
+        jwk = key.serialize()
+        if jwk not in jar:
+            jar.append(jwk)
+            _keys.append(key)
+    if _keys:
+        keyjar.add_keys(entity_id, _keys)
+    return keyjar


diff --git a/src/idpyoidc/metadata.py b/src/idpyoidc/metadata.py
index 7561d48..e69de29 100644
--- a/src/idpyoidc/metadata.py
+++ b/src/idpyoidc/metadata.py
@@ -1,274 +0,0 @@
-from functools import cmp_to_key
-import logging
-from typing import Callable
-from typing import Optional
-
-from cryptojwt import KeyJar
-from cryptojwt.jwe import SUPPORTED
-from cryptojwt.jws.jws import SIGNER_ALGS
-from cryptojwt.key_jar import init_key_jar
-from cryptojwt.utils import importer
-
-from idpyoidc.client.util import get_uri
-from idpyoidc.impexp import ImpExp
-from idpyoidc.util import add_path
-from idpyoidc.util import qualified_name
-
-logger = logging.getLogger(__name__)
-
-
-def metadata_dump(info, exclude_attributes):
-    return {qualified_name(info.__class__): info.dump(exclude_attributes=exclude_attributes)}
-
-
-def metadata_load(item: dict, **kwargs):
-    _class_name = list(item.keys())[0]  # there is only one
-    _cls = importer(_class_name)
-    _cls = _cls().load(item[_class_name])
-    return _cls
-
-
-class Metadata(ImpExp):
-    parameter = {"prefer": None, "use": None, "callback_path": None, "_local": None}
-
-    _supports = {}
-
-    def __init__(self, prefer: Optional[dict] = None, callback_path: Optional[dict] = None):
-
-        ImpExp.__init__(self)
-        if isinstance(prefer, dict):
-            self.prefer = {k: v for k, v in prefer.items() if k in self._supports}
-        else:
-            self.prefer = {}
-
-        self.callback_path = callback_path or {}
-        self.use = {}
-        self._local = {}
-
-    def get_use(self):
-        return self.use
-
-    def set_usage(self, key, value):
-        self.use[key] = value
-
-    def get_usage(self, key, default=None):
-        return self.use.get(key, default)
-
-    def get_preference(self, key, default=None):
-        return self.prefer.get(key, default)
-
-    def set_preference(self, key, value):
-        self.prefer[key] = value
-
-    def remove_preference(self, key):
-        if key in self.prefer:
-            del self.prefer[key]
-
-    def _callback_uris(self, base_url, hex):
-        _uri = []
-        for type in self.get_usage("response_types", self._supports["response_types"]):
-            if "code" in type:
-                _uri.append("code")
-            elif type in ["id_token", "id_token token"]:
-                _uri.append("implicit")
-
-        if "form_post" in self.supports:
-            _uri.append("form_post")
-
-        callback_uri = {}
-        for key in _uri:
-            callback_uri[key] = get_uri(base_url, self.callback_path[key], hex)
-        return callback_uri
-
-    def construct_redirect_uris(self, base_url: str, hex: str, callbacks: Optional[dict] = None):
-        if not callbacks:
-            callbacks = self._callback_uris(base_url, hex)
-
-        if callbacks:
-            self.set_preference("callbacks", callbacks)
-            self.set_preference("redirect_uris", [v for k, v in callbacks.items()])
-
-        self.callback = callbacks
-
-    def verify_rules(self, supports):
-        return True
-
-    def locals(self, info):
-        pass
-
-    def _keyjar(self, keyjar=None, conf=None, entity_id=""):
-        _uri_path = ""
-        if keyjar is None:
-            if "keys" in conf:
-                keys_args = {k: v for k, v in conf["keys"].items() if k != "uri_path"}
-                _keyjar = init_key_jar(**keys_args)
-                _uri_path = conf["keys"].get("uri_path")
-            elif "key_conf" in conf and conf["key_conf"]:
-                keys_args = {k: v for k, v in conf["key_conf"].items() if k != "uri_path"}
-                _keyjar = init_key_jar(**keys_args)
-                _uri_path = conf["key_conf"].get("uri_path")
-            else:
-                _keyjar = KeyJar()
-                if "jwks" in conf:
-                    _keyjar.import_jwks(conf["jwks"], "")
-
-            if "" in _keyjar and entity_id:
-                # make sure I have the keys under my own name too (if I know it)
-                _keyjar.import_jwks_as_json(_keyjar.export_jwks_as_json(True, ""), entity_id)
-
-            _httpc_params = conf.get("httpc_params")
-            if _httpc_params:
-                _keyjar.httpc_params = _httpc_params
-
-            return _keyjar, _uri_path
-        else:
-            if "keys" in conf:
-                _uri_path = conf["keys"].get("uri_path")
-            elif "key_conf" in conf and conf["key_conf"]:
-                _uri_path = conf["key_conf"].get("uri_path")
-            return keyjar, _uri_path
-
-    def get_base_url(self, configuration: dict, entity_id: Optional[str] = ""):
-        raise NotImplementedError()
-
-    def get_id(self, configuration: dict):
-        raise NotImplementedError()
-
-    def add_extra_keys(self, keyjar, id):
-        return None
-
-    def get_jwks(self, keyjar):
-        return None
-
-    def handle_keys(self,
-                    configuration: dict,
-                    keyjar: Optional[KeyJar] = None,
-                    base_url: Optional[str] = "",
-                    entity_id: Optional[str] = ""):
-        _jwks = _jwks_uri = None
-        _id = self.get_id(configuration)
-        keyjar, uri_path = self._keyjar(keyjar, configuration, entity_id=_id)
-
-        self.add_extra_keys(keyjar, _id)
-
-        # now that keys are in the Key Jar, now for how to publish it
-        if "jwks_uri" in configuration:  # simple
-            _jwks_uri = configuration.get("jwks_uri")
-        elif uri_path:
-            if not base_url:
-                base_url = self.get_base_url(configuration, entity_id=entity_id)
-            _jwks_uri = add_path(base_url, uri_path)
-        else:  # jwks or nothing
-            _jwks = self.get_jwks(keyjar)
-
-        return {"keyjar": keyjar, "jwks": _jwks, "jwks_uri": _jwks_uri}
-
-    def load_conf(
-            self, configuration, supports, keyjar: Optional[KeyJar] = None,
-            base_url: Optional[str] = ""
-    ):
-        for attr, val in configuration.items():
-            if attr == "preference":
-                for k, v in val.items():
-                    if k in supports:
-                        self.set_preference(k, v)
-            elif attr in supports:
-                self.set_preference(attr, val)
-
-        self.locals(configuration)
-
-        for key, val in self.handle_keys(configuration, keyjar=keyjar, base_url=base_url).items():
-            if key == "keyjar":
-                keyjar = val
-            elif val:
-                self.set_preference(key, val)
-
-        self.verify_rules(supports)
-        return keyjar
-
-    def get(self, key, default=None):
-        if key in self._local:
-            return self._local[key]
-        else:
-            return default
-
-    def set(self, key, val):
-        self._local[key] = val
-
-    def construct_uris(self, *args):
-        pass
-
-    def supports(self):
-        res = {}
-        for key, val in self._supports.items():
-            if isinstance(val, Callable):
-                res[key] = val()
-            else:
-                res[key] = val
-        return res
-
-    def supported(self, claim):
-        return claim in self._supports
-
-    def prefers(self):
-        return self.prefer
-
-
-SIGNING_ALGORITHM_SORT_ORDER = ["RS", "ES", "PS", "HS", "Ed"]
-
-
-def cmp(a, b):
-    return (a > b) - (a < b)
-
-
-def alg_cmp(a, b):
-    if a == "none":
-        return 1
-    elif b == "none":
-        return -1
-
-    _pos1 = SIGNING_ALGORITHM_SORT_ORDER.index(a[0:2])
-    _pos2 = SIGNING_ALGORITHM_SORT_ORDER.index(b[0:2])
-    if _pos1 == _pos2:
-        return (a > b) - (a < b)
-    elif _pos1 > _pos2:
-        return 1
-    else:
-        return -1
-
-
-def get_signing_algs():
-    # Assumes Cryptojwt
-    _algs = [name for name in list(SIGNER_ALGS.keys()) if name != "none"]
-    return sorted(_algs, key=cmp_to_key(alg_cmp))
-
-
-def get_encryption_algs():
-    return SUPPORTED["alg"]
-
-
-def get_encryption_encs():
-    return SUPPORTED["enc"]
-
-
-def array_or_singleton(claim_spec, values):
-    if isinstance(claim_spec[0], list):
-        if isinstance(values, list):
-            return values
-        else:
-            return [values]
-    else:
-        if isinstance(values, list):
-            return values[0]
-        else:  # singleton
-            return values
-
-
-def is_subset(a, b):
-    if isinstance(a, list):
-        if isinstance(b, list):
-            return set(b).issubset(set(a))
-    elif isinstance(b, list):
-        return a in b
-    else:
-        return a == b

diff --git a/src/idpyoidc/node.py b/src/idpyoidc/node.py
index 0db622a..2b64d6e 100644
--- a/src/idpyoidc/node.py
+++ b/src/idpyoidc/node.py
@@ -7,14 +7,17 @@ from cryptojwt.key_jar import init_key_jar

 from idpyoidc.configure import Configuration
 from idpyoidc.impexp import ImpExp
+from idpyoidc.key_import import import_jwks
+from idpyoidc.key_import import import_jwks_as_json
+from idpyoidc.key_import import store_under_other_id
 from idpyoidc.util import instantiate


 def create_keyjar(
-    keyjar: Optional[KeyJar] = None,
-    conf: Optional[Union[dict, Configuration]] = None,
-    key_conf: Optional[dict] = None,
-    id: Optional[str] = "",
+        keyjar: Optional[KeyJar] = None,
+        conf: Optional[Union[dict, Configuration]] = None,
+        key_conf: Optional[dict] = None,
+        id: Optional[str] = "",
 ):
     if keyjar is None:
         if key_conf:
@@ -30,13 +33,13 @@ def create_keyjar(
             else:
                 _keyjar = KeyJar()
                 if "jwks" in conf:
-                    _keyjar.import_jwks(conf["jwks"], "")
+                    _keyjar = import_jwks(_keyjar, conf["jwks"], "")
         else:
             _keyjar = None

         if _keyjar and "" in _keyjar and id:
             # make sure I have the keys under my own name too (if I know it)
-            _keyjar.import_jwks_as_json(_keyjar.export_jwks_as_json(True, ""), id)
+            _keyjar = store_under_other_id(_keyjar, "", id, True)

         return _keyjar
     else:
@@ -60,7 +63,7 @@ def make_keyjar(
         keyjar = KeyJar()
         _jwks = config.get("jwks")
         if _jwks:
-            keyjar.import_jwks_as_json(_jwks, client_id)
+            keyjar = import_jwks_as_json(keyjar, _jwks, client_id)

     if keyjar or key_conf:
         # Should be either one
@@ -78,15 +81,12 @@ def make_keyjar(
                 keyjar = KeyJar()
                 keyjar.add_symmetric(client_id, _key)
                 keyjar.add_symmetric("", _key)
-        # else:
-        #     keyjar = build_keyjar(DEFAULT_KEY_DEFS)
-        #     if issuer_id:
-        #         keyjar.import_jwks(keyjar.export_jwks(private=True), issuer_id)

     return keyjar


 class Node:
+
     def __init__(self, upstream_get: Callable = None):
         self.upstream_get = upstream_get

@@ -123,19 +123,20 @@ class Unit(ImpExp):
     init_args = ["upstream_get"]

     def __init__(
-        self,
-        upstream_get: Callable = None,
-        keyjar: Optional[Union[KeyJar, bool]] = None,
-        httpc: Optional[object] = None,
-        httpc_params: Optional[dict] = None,
-        config: Optional[Union[Configuration, dict]] = None,
-        key_conf: Optional[dict] = None,
-        issuer_id: Optional[str] = "",
-        client_id: Optional[str] = "",
+            self,
+            upstream_get: Callable = None,
+            keyjar: Optional[Union[KeyJar, bool]] = None,
+            httpc: Optional[object] = None,
+            httpc_params: Optional[dict] = None,
+            config: Optional[Union[Configuration, dict]] = None,
+            key_conf: Optional[dict] = None,
+            issuer_id: Optional[str] = "",
+            client_id: Optional[str] = "",
     ):
         ImpExp.__init__(self)
         self.upstream_get = upstream_get
         self.httpc = httpc
+        self.client_id = client_id

         if config is None:
             config = {}
@@ -192,16 +193,16 @@ class ClientUnit(Unit):
     name = ""

     def __init__(
-        self,
-        upstream_get: Callable = None,
-        httpc: Optional[object] = None,
-        httpc_params: Optional[dict] = None,
-        keyjar: Optional[KeyJar] = None,
-        context: Optional[ImpExp] = None,
-        config: Optional[Union[Configuration, dict]] = None,
-        # jwks_uri: Optional[str] = "",
-        entity_id: Optional[str] = "",
-        key_conf: Optional[dict] = None,
+            self,
+            upstream_get: Callable = None,
+            httpc: Optional[object] = None,
+            httpc_params: Optional[dict] = None,
+            keyjar: Optional[KeyJar] = None,
+            context: Optional[ImpExp] = None,
+            config: Optional[Union[Configuration, dict]] = None,
+            # jwks_uri: Optional[str] = "",
+            entity_id: Optional[str] = "",
+            key_conf: Optional[dict] = None,
     ):
         if config is None:
             config = {}
@@ -232,17 +233,18 @@ class ClientUnit(Unit):

 # Neither client nor Server
 class Collection(Unit):
+
     def __init__(
-        self,
-        upstream_get: Callable = None,
-        keyjar: Optional[KeyJar] = None,
-        httpc: Optional[object] = None,
-        httpc_params: Optional[dict] = None,
-        config: Optional[Union[Configuration, dict]] = None,
-        entity_id: Optional[str] = "",
-        key_conf: Optional[dict] = None,
-        functions: Optional[dict] = None,
-        claims: Optional[dict] = None,
+            self,
+            upstream_get: Callable = None,
+            keyjar: Optional[KeyJar] = None,
+            httpc: Optional[object] = None,
+            httpc_params: Optional[dict] = None,
+            config: Optional[Union[Configuration, dict]] = None,
+            entity_id: Optional[str] = "",
+            key_conf: Optional[dict] = None,
+            functions: Optional[dict] = None,
+            claims: Optional[dict] = None,
     ):
         if config is None:
             config = {}

